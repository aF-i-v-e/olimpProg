package feodor;

public class Task220222 {
    /*
    практики через неделю
    проект
    3 варианта - робот, проект Клепинина, смысл - разобраться в коде другого
    проект, задачи, реализация
    Разбалловка - кол-во задач + фичи(подходы из лекций, шаблоны проектирования - наиболее хороший вариант решения
    какой-либо проблемы)
    Банда четырёх - про шаблоны проектов, книга "Шаблоны проектирования"
    Есть на руссоком языке
    - робот
    клеточное поле, на них боты, еда
    У бота есть энергия, задача - выжить, есть и бить других
    У бота есть геном - набор последовательных команд, которые он выполняет(съешь, переместись на клетку)
    Живут пока не вымрут, меняем случайно одну команду в геноме, размножаем и опять запускаем жить "Генетический алгоритм"
    условия. начальные данные, идея классического отбора
    -выбираем свой проект, согласуем с Ф, начинать с 0.

    Чем не с++?
    порог вхождения, сложно, легко ошибиться
    в java ооп, стандарт, основные принципы
    в Java memory model, взаимодействие с память, garbage collector - создание. удаление объектов,
     память скрыта, оптимизация. Разработчик напрямую с памятью не работает.(в этом плюс в отличие от с++)
     По умолчанию хеш код возваращает модифицированный идентификатор объекта, ссылка может меняться со временем
     == сравнение значений на стеке
     объект лежит в куче, значение лежит на стеке
     метод equals - сравнение объектов
     Стек, куча
     java динамически подгружает классы, в памяти хранит минимум,который использует программа.
     синглтон - паттерн проектирования. который говорит, что объект класса всегда 1.
     this - ссылка на теущий объект
    * */

    private static volatile Main main;
    private Task220222() {}

    /*
    * приватный конструктор, чтобы нельзя было создать извне
    * */
    public static Main getInstance() {
        if (main == null) {
            synchronized (Main.class) {
                if (main == null) {
                    main = new Main();
                }
            }
        }
        return main;
    }

    public static void main(String[] args) {
        Main main  = new Main();
        // B b = new B(); так делать нельзя т.к метод этот статический
    }
    /*
    Когда стоит писать вложенные классы?
    ограничение видимости
    внутренний дата класс
    * */

    /*
    Что делать с текстовыми константами?
    в обычном классе public static final String  a = " kfkm"
    Вынести в интерфейс
    default - уже реализован метод
    String a = "hdfh"; Это развернется в равносильный для класса.
    Локализация, не подходит

    Enum
    конструкторы
    реализация интерфейсы
    методы
    Во что превращается после компиляции?
    Если это перечисление, когда есть случаи и точно знаем, что других случаев не будет

    Использование конкретных версий java.
    Совет: выбирать старшую из последних версий.

    Гил у питон про многопоточность

    дедлоки, состояние гонки(2 параллельных потоков, борются за одну переменную, Потоки соревнуются, кто быстрее
    изменит переменнюую, состояние конкуренции)
    Инкапсуляция, полиморфизм, наследование, абстракции, интерфейсы
    шаблоны пректирования(есть классическая задача, её надо решать проверенным методом)
    солед (солид - акроним, абревеатура, соединяющая в себе другие абревеатуры)
    5 базовых принципов построения программы
    1. Сингл респонсибилити = единая обязанность, 1 класс - 1 обязанность
    Почему? Знаем где искать ошибки, много кода, сложно читать и понимать, легко работать вдвоём
    еще 4 смотреть самому

    код стайл
    java конвенция
    CamelCase
    Вячеслав Копейцев - ТОЛЬКО НЕ ВОПРОСЫ
    Базовые принципы ООП, сдаём очно = в том виде, в которм сдаём практики
    * */

    /*
    Сколько занимает объект в java?
    Алексей Шепелёв
    hotSpot
    в каждой jvm ответ свой, зависит от неё.
    Классическая jvm:
    метаинформация об объекте 12 - 20 байт, хеш код, результаты хеш кода сохраняются в объекте
    компилятор может делать свои оптимизации, поэтому опять не можем сказать размер объекта
    Знаем про стринг, дабл - там фиксировано
    Использовать, что гарантировано разработчиками jvm.
    * */

    /*классы можно объявлять внутри классов
    сейчас бест практис - это то, что ниже:
    * */
    /*
    чем отличается, когда пишем статик у класса, а когда нет
    * */
    private static class A{}
    private class B{} //лучше никогда не использовать

    private static class INSTANCE {
        public static final Main instance = new Main();
    }
}
